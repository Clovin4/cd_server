name: Terraform Infra

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      action:
        description: "Action to perform"
        required: true
        default: "apply"
        type: choice
        options:
          - "apply"
          - "destroy"

env:
  ACTION: ${{ github.event.inputs.action || 'apply' }}

jobs:
  terraform:
    runs-on: ubuntu-latest

    outputs:
      vm_public_ips: ${{ steps.tfout.outputs.vm_public_ips }}
      vm_private_ips: ${{ steps.tfout.outputs.vm_private_ips }}
      action: ${{ steps.set-action.outputs.action }}

    steps:
      - name: Set action output
        id: set-action
        run: echo "action=${{ env.ACTION }}" >> "$GITHUB_OUTPUT"

      - name: Checkout
        uses: actions/checkout@v4

      - name: Get Secrets (Bitwarden)
        uses: bitwarden/sm-action@v2
        with:
          access_token: ${{ secrets.BW_ACCESS_TOKEN }}
          base_url: https://vault.bitwarden.com
          secrets: |
            9aae3c8c-e6ad-498b-81f4-b350016b6af6 > DO_TOKEN
            8ba24b65-ef89-458f-bb78-b350016a8bf0 > DO_SSH_KEY_FINGERPRINT
            5e5ed78b-2b00-4b79-92fe-b3d9002e2787 > DO_SPACES_ACCESS_KEY
            d8be869f-c376-4acf-8a01-b3d9002dfc71 > DO_SPACES_SECRET_KEY

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Ensure Spaces state bucket exists
        env:
          SPACES_ACCESS_KEY: ${{ env.DO_SPACES_ACCESS_KEY }}
          SPACES_SECRET_KEY: ${{ env.DO_SPACES_SECRET_KEY }}
        run: |
          curl -sL https://github.com/digitalocean/doctl/releases/download/v1.119.0/doctl-1.119.0-linux-amd64.tar.gz | tar -xz
          sudo mv doctl /usr/local/bin

          aws configure set aws_access_key_id "$SPACES_ACCESS_KEY"
          aws configure set aws_secret_access_key "$SPACES_SECRET_KEY"

          if aws s3api head-bucket \
              --bucket lazy1-tfstate \
              --endpoint-url https://nyc3.digitaloceanspaces.com 2>/dev/null; then
            echo "✓ Bucket lazy1-tfstate already exists"
          else
            echo "Bucket not found — creating lazy1-tfstate in nyc3..."
            aws s3api create-bucket \
              --bucket lazy1-tfstate \
              --endpoint-url https://nyc3.digitaloceanspaces.com
            echo "✓ Bucket created"
          fi

      - name: Terraform Init
        working-directory: infra
        env:
          AWS_ACCESS_KEY_ID: ${{ env.DO_SPACES_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ env.DO_SPACES_SECRET_KEY }}
        run: terraform init -upgrade

      - name: Terraform Apply
        if: env.ACTION == 'apply'
        working-directory: infra
        env:
          AWS_ACCESS_KEY_ID: ${{ env.DO_SPACES_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ env.DO_SPACES_SECRET_KEY }}
          TF_VAR_do_token: ${{ env.DO_TOKEN }}
          TF_VAR_ssh_key_fingerprint: ${{ env.DO_SSH_KEY_FINGERPRINT }}
        run: terraform apply -auto-approve

      - name: Terraform Destroy
        if: env.ACTION == 'destroy'
        working-directory: infra
        env:
          AWS_ACCESS_KEY_ID: ${{ env.DO_SPACES_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ env.DO_SPACES_SECRET_KEY }}
          TF_VAR_do_token: ${{ env.DO_TOKEN }}
          TF_VAR_ssh_key_fingerprint: ${{ env.DO_SSH_KEY_FINGERPRINT }}
        run: terraform destroy -auto-approve

      - name: Show VM IPs
        if: env.ACTION == 'apply'
        id: tfout
        working-directory: infra
        env:
          AWS_ACCESS_KEY_ID: ${{ env.DO_SPACES_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ env.DO_SPACES_SECRET_KEY }}
        run: |
          echo "=== VM Public IPs ==="
          terraform output -json vm_ips

          echo "=== VM Private IPs ==="
          terraform output -json vm_private_ips

          echo ""
          echo "=== /etc/hosts block ==="
          terraform output -raw hosts_file_entries

          echo ""
          echo "=== ~/.ssh/config block ==="
          terraform output -raw ssh_config

          # Capture both IP maps as job outputs for the ansible job
          echo "vm_public_ips=$(terraform output -json vm_ips)" >> "$GITHUB_OUTPUT"
          echo "vm_private_ips=$(terraform output -json vm_private_ips)" >> "$GITHUB_OUTPUT"

  ansible:
    runs-on: ubuntu-latest
    needs: terraform
    if: needs.terraform.outputs.action == 'apply'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get Secrets (Bitwarden)
        uses: bitwarden/sm-action@v2
        with:
          access_token: ${{ secrets.BW_ACCESS_TOKEN }}
          base_url: https://vault.bitwarden.com
          secrets: |
            12138ca7-50d2-45ce-a231-b3d900307a3a > SSH_PRIVATE_KEY

      - name: Install Ansible
        run: |
          sudo apt-get update -q
          sudo apt-get install -y ansible

      - name: Setup CI runner SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub

      # Generate a fresh ed25519 keypair for the jumpbox on every apply.
      # The public key is pushed to all nodes during setup.yml so they trust
      # the jumpbox from the moment root SSH is locked out.
      # The private key is placed on the jumpbox during jumpbox.yml.
      - name: Generate jumpbox SSH keypair
        run: |
          ssh-keygen -t ed25519 -f /tmp/jumpbox_id_ed25519 -N "" -C "jumpbox@kthw"
          echo "JUMPBOX_PUBKEY=$(cat /tmp/jumpbox_id_ed25519.pub)" >> "$GITHUB_ENV"

      - name: Build Ansible inventory
        env:
          VM_PUBLIC_IPS: ${{ needs.terraform.outputs.vm_public_ips }}
          VM_PRIVATE_IPS: ${{ needs.terraform.outputs.vm_private_ips }}
        run: |
          python3 - <<'EOF'
          import json, os

          pub  = json.loads(os.environ['VM_PUBLIC_IPS'])
          priv = json.loads(os.environ['VM_PRIVATE_IPS'])

          pod_subnets = {
              'node-0': '10.200.0.0/24',
              'node-1': '10.200.1.0/24',
          }

          lines = [
              '[jumpbox]',
              f"jumpbox ansible_host={pub['jumpbox']} private_ip={priv['jumpbox']}",
              '',
              '[control_plane]',
              f"server ansible_host={pub['server']} private_ip={priv['server']}",
              '',
              '[workers]',
          ]
          for node in ['node-0', 'node-1']:
              lines.append(
                  f"{node} ansible_host={pub[node]} "
                  f"private_ip={priv[node]} "
                  f"pod_subnet={pod_subnets[node]}"
              )
          lines += [
              '',
              '[cluster:children]',
              'control_plane',
              'workers',
              '',
              '[all:vars]',
              'ansible_user=root',
              'ansible_ssh_private_key_file=~/.ssh/id_rsa',
              'ansible_ssh_common_args=-o StrictHostKeyChecking=accept-new',
          ]

          os.makedirs('inventory', exist_ok=True)
          with open('inventory/hosts', 'w') as f:
              f.write('\n'.join(lines) + '\n')

          print("=== Generated inventory ===")
          print('\n'.join(lines))
          EOF

      - name: Run site.yml
        env:
          ANSIBLE_HOST_KEY_CHECKING: "false"
        run: |
          # Read the private key from the filesystem — don't store it in an env var
          # where it might leak into logs. The receiving task has no_log: true.
          JUMPBOX_PRIVKEY=$(cat /tmp/jumpbox_id_ed25519)

          ansible-playbook \
            -i inventory/hosts \
            -e "jumpbox_private_key=${JUMPBOX_PRIVKEY}" \
            -e "{\"extra_authorized_keys\": [\"${JUMPBOX_PUBKEY}\"]}" \
            playbooks/site.yml
